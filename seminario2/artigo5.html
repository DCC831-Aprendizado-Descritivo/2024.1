<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.55">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Artigo 5: For Real: A Thorough Look at Numeric Attributes in Subgroup Discovery – Aprendizado Descritivo</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-seminário-1" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Seminário 1</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-seminário-1">    
        <li>
    <a class="dropdown-item" href="../seminario1/artigo1.html">
 <span class="dropdown-text">Artigo 1: A Survey of High Utility Itemset Mining</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../seminario1/artigo2.html">
 <span class="dropdown-text">Artigo 2: Finding Local Groupings of Time Series</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../seminario1/artigo3.html">
 <span class="dropdown-text">Artigo 3: Representation Learning for Frequent Subgraph Mining</span></a>
  </li>  
    </ul>
  </li>
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#contextualização-do-problema" id="toc-contextualização-do-problema" class="nav-link active" data-scroll-target="#contextualização-do-problema">Contextualização do problema</a></li>
  <li><a href="#conceitos-importantes" id="toc-conceitos-importantes" class="nav-link" data-scroll-target="#conceitos-importantes">Conceitos importantes</a></li>
  <li><a href="#entendendo-os-algoritmos-usados" id="toc-entendendo-os-algoritmos-usados" class="nav-link" data-scroll-target="#entendendo-os-algoritmos-usados">Entendendo os algoritmos usados</a></li>
  <li><a href="#estratégias-de-busca" id="toc-estratégias-de-busca" class="nav-link" data-scroll-target="#estratégias-de-busca">Estratégias de busca</a></li>
  <li><a href="#metodologia" id="toc-metodologia" class="nav-link" data-scroll-target="#metodologia">Metodologia</a></li>
  <li><a href="#resultados-obtidos" id="toc-resultados-obtidos" class="nav-link" data-scroll-target="#resultados-obtidos">Resultados obtidos</a></li>
  <li><a href="#aplicações-e-desafios" id="toc-aplicações-e-desafios" class="nav-link" data-scroll-target="#aplicações-e-desafios">Aplicações e desafios</a></li>
  <li><a href="#execução-dos-algoritmos-usados-no-artigo" id="toc-execução-dos-algoritmos-usados-no-artigo" class="nav-link" data-scroll-target="#execução-dos-algoritmos-usados-no-artigo">Execução dos algoritmos usados no artigo</a></li>
  <li><a href="#conclusão" id="toc-conclusão" class="nav-link" data-scroll-target="#conclusão">Conclusão</a></li>
  <li><a href="#referências" id="toc-referências" class="nav-link" data-scroll-target="#referências">Referências</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content column-page-left" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Artigo 5: For Real: A Thorough Look at Numeric Attributes in Subgroup Discovery</h1>
</div>



<div class="quarto-title-meta column-page-left">

    
  
    
  </div>
  


</header>


<p>A descoberta de subgrupos (SD) é um método de mineração de dados que visa identificar padrões interessantes dentro de grandes conjuntos de dados, destacando segmentos específicos que diferem de forma significativa do restante. Este método é particularmente útil para explorar dados e encontrar subgrupos que apresentam comportamentos ou características notáveis.</p>
<figure align="center" class="figure">
<img src="imgs/artigo5/introducao.png" style="max-width: 100%;" class="figure-img">
<figcaption>
Descoberta de subgrupos
</figcaption>
</figure>
<p>No contexto da SD, os dados numéricos desempenham um papel crucial. Eles podem ser usados tanto como atributos de descrição, que ajudam a definir os subgrupos, quanto como alvos, onde se analisa o valor numérico em si. A forma como esses dados numéricos são tratados pode impactar significativamente a qualidade e a utilidade dos subgrupos descobertos. Com isso, é importante que a aplicação de métodos SD sejam adaptadas para lidar com esse tipo de dado da melhor forma possível.</p>
<section id="contextualização-do-problema" class="level2">
<h2 class="anchored" data-anchor-id="contextualização-do-problema">Contextualização do problema</h2>
<p>Historicamente, o tratamento de dados numéricos em algoritmos de descoberta de subgrupos tem sido predominantemente estático e global. Um exemplo disso é o mergeSD (2009), que abordou o tratamento de dados numéricos, embora com um aumento significativo no custo computacional. No entanto, muitos algoritmos clássicos ainda não tratam adequadamente os atributos numéricos, resultando na perda de informações relevantes e na diminuição da eficiência do modelo.</p>
<p>Para abordar essa questão, o artigo investiga qual abordagem é mais eficaz para lidar com esses atributos, utilizando um framework que compara diferentes estratégias de discretização de dados numéricos e de busca de subgrupos. A motivação central dos autores é compreender como a discretização dos valores numéricos pode ser realizada de maneira a preservar a qualidade e a redundância mínima nos subgrupos descobertos. Assim, o artigo pode ser visto como uma revisão dos principais métodos de tratamento de atributos numéricos em SD.</p>
</section>
<section id="conceitos-importantes" class="level2">
<h2 class="anchored" data-anchor-id="conceitos-importantes">Conceitos importantes</h2>
<p>A descoberta de subgrupos lida com atributos numéricos por meio de condições nos valores, discretizando-os em intervalos para tornar o problema tratável. A discretização pode ser realizada de forma global, no início do processo, com todos os pontos de corte definidos de uma vez, ou de forma local, sendo realizada dinamicamente durante a mineração.</p>
<p>Os intervalos gerados pela discretização podem ser binários ou nominais. Intervalos binários referem-se a divisões simples em duas categorias, como “baixo” e “alto”, enquanto intervalos nominais podem ter múltiplas categorias como “baixo”, “médio” e “alto”. No entanto, os autores mencionam que essa simplificação resultante da discretização pode descaracterizar os dados, pois os valores perdem certas propriedades ao serem agrupados em categorias. Por exemplo, ao comparar valores numéricos em um conjunto que varia de 1 a 10, os valores 7 e 8 podem ser categorizados como “alto”, fazendo com que 7 deixe de ser menor que 8, pois ambos são apenas “alto”.</p>
<p>A tabela abaixo mostra um exemplo prático de discretização do atributo “height” (altura) de um grupo de 13 indivíduos usando a estratégia nominal e binária. Na estratégia nominal (coluna heightn), os pontos de corte foram definidos para os intervalos a ≤ 170 &lt; b ≤ 179 &lt; c.&nbsp;Já na estratégia binária temos duas categorias: low (coluna heightl) e low/medium (coluna heightlm) que correspondem a uma forma alternativa de discretizar os pontos de corte da estratégia nominal.</p>
<figure align="center" class="figure">
<img src="imgs/artigo5/exemplodiscretizacao.png" style="max-width: 100%;" class="figure-img">
<figcaption>
Exemplo de estratégias de discretização para atributos numéricos
</figcaption>
</figure>
<p>A granularidade para discretização refere-se ao nível de detalhe ou ao número de candidatos (intervalos) em que os dados numéricos são divididos. Granularidade fina envolve a criação de muitos intervalos pequenos, enquanto a granularidade grossa gera poucos intervalos maiores. Uma granularidade mais fina permite uma análise mais detalhada, mas pode aumentar o custo computacional. A seleção de candidatos pode incluir todos os possíveis subgrupos (all) ou apenas um subconjunto (best), o que também impacta o custo computacional.</p>
</section>
<section id="entendendo-os-algoritmos-usados" class="level2">
<h2 class="anchored" data-anchor-id="entendendo-os-algoritmos-usados">Entendendo os algoritmos usados</h2>
<p>Para dar suporte à investigação, os pesquisadores parametrizaram e executaram dois algoritmos de base: um para a descoberta de subgrupos e outro para a discretização de atributos numéricos.</p>
<p>O primeiro algoritmo, SDMM, realiza a busca de subgrupos válidos em uma base de dados, utilizando uma função de qualidade, restrições e estratégias de busca pré-estabelecidas. O algoritmo explora o dados, criando um primeiro subgrupo de busca e refinando o banco de dados a partir dele, com o objetivo de gerar novos candidatos para validação. Cada candidato é analisado, uma função de qualidade é associada a ele e é verificado se os candidatos seguem o padrão de qualidade estabelecido. Se sim, esses dados são adicionados ao conjunto solução; caso contrário, a busca é reiniciada.</p>
<p>O segundo algoritmo, Equal Frequency Discretisation, é um algoritmo de discretização que desenvolve intervalos de classe. No início do processo, é definido como os atributos numéricos serão discretizados, estabelecendo o número de intervalos de classes e, a partir desse número, o algoritmo define os pontos de corte das classes para categorizar os atributos.</p>
</section>
<section id="estratégias-de-busca" class="level2">
<h2 class="anchored" data-anchor-id="estratégias-de-busca">Estratégias de busca</h2>
<p>Para gerar os quadros de simulações possíveis e comparar as melhores soluções de descoberta de subgrupos, são utilizados três métodos principais: busca em feixe tradicional, busca em feixe CBSS e busca completa.</p>
<p>A busca em feixe tradicional é uma busca em nível, que limita o número de candidatos e a cada processamento. O método é ajustado para buscar subgrupos de acordo com um valor predefinido, restringindo o número de candidatos considerados em cada etapa.</p>
<p>A busca em feixe em CBSS é uma variação do feixe tradicional, que gera supercandidatos preliminares. Para otimizar a busca dos melhores candidatos, ele incrementa o número de candidatos, visando aumentar a diversidade do processo.</p>
<p>A busca completa realiza uma busca extensa usando todos os candidatos na busca de subgrupos. Embora isso aumente a qualidade da descoberta, há um custo operacional elevado e redundância. Trabalhar com grandes bancos de dados pode ser difícil e, apesar de melhorar a qualidade, a performance pode ser prejudicada.</p>
<figure align="center" class="figure">
<img src="imgs/artigo5/diagrama1.png" style="max-width: 100%;" class="figure-img">
<figcaption>
Diagrama de etapas do processamento de dados para descoberta de subgrupos
</figcaption>
</figure>
</section>
<section id="metodologia" class="level2">
<h2 class="anchored" data-anchor-id="metodologia">Metodologia</h2>
<p>No que diz respeito à metodologia do artigo, os autores realizaram uma série de testes, com todas as combinações de hiperparâmetros e estratégias possíveis. Ao todo, forma avaliados 5 aspectos diferentes de SD e como cada um deles impacta os resultados, são estes:</p>
<ol type="1">
<li>Hiperparâmetros, que se dividem em 2 tipos:
<ul>
<li>Número de bins: quantidade de quebras na discretização.</li>
<li>Profundidade: número de descritores.</li>
</ul></li>
<li>Estratégias para o SD numérico que variam em 4 dimensões, havendo duas opções para cada e, portanto, 2^4 possibilidades:
<ul>
<li>Momento de discretização (local ou global).</li>
<li>Tipo de intervalo (binário ou nominal).</li>
<li>Granularidade (fina ou grossa).</li>
<li>Métodos de seleção (“all” ou “best”).</li>
</ul></li>
<li>Datasets utilizados, que podem ser para dois tipos de problemas:
<ul>
<li>Datasets de classificação e regras não supervisionados, ex: covertype, credit-a, outros.</li>
<li>Datasets de regressão, ex: auto-mpg, abalone, outros.</li>
</ul></li>
<li>Estratégia de busca:
<ul>
<li>Complete search: envolve a exploração de todo o espaço de busca.</li>
<li>Beam search: limita o número de candidatos a cada nível da busca.</li>
<li>Beam search + CBSS: otimização para tentar reduzir a redundância dos subgrupos.</li>
</ul></li>
<li>Métricas de avaliação:
<ul>
<li>WRAcc: para classificação.</li>
<li>z-score: para regressão.</li>
<li>Entropia conjunta: para calcular a redundância dos top 10 subgrupos.</li>
</ul></li>
</ol>
<p>Para avaliar esses aspectos, foram realizados 17.020 experimentos, utilizando o algoritmo SDMM. Os experimentos utilizaram seis datasets de classificação e seis datasets de regressão e foram avaliados através de WRAcc para classificação e |z-score| para regressão.</p>
</section>
<section id="resultados-obtidos" class="level2">
<h2 class="anchored" data-anchor-id="resultados-obtidos">Resultados obtidos</h2>
<p>As conclusões sobre vários aspectos obtidas com os resultados dos experimentos podem ser vistas de forma resumina no quadro a seguir:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 15%">
<col style="width: 84%">
</colgroup>
<thead>
<tr class="header">
<th>Aspecto metodológico</th>
<th>Conclusão</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Discretização</td>
<td>Não existe regra universal para o número de bins. Estratégias nominais têm melhor desempenho com números de bins menores, mas estratégias binárias são preferíveis em todos os contextos e aplicações. A discretização local é sempre melhor.</td>
</tr>
<tr class="even">
<td>Busca</td>
<td>A escolha da heurística de busca tem pouco impacto. Beam search é recomendada por ser eficiente e apresentar resultados bons quanto à complete search. Em datasets pequenos, a busca completa pode ser útil. CBSS reduz a redundância, mas não melhora a qualidade.</td>
</tr>
<tr class="odd">
<td>Métricas de Qualidade</td>
<td>As métricas impactam significativamente nos subgrupos gerados, especialmente nos tamanhos, favorecendo subgrupos maiores. Avaliação feita com a correlação de Pearson.</td>
</tr>
<tr class="even">
<td>Granularidade</td>
<td>A granularidade fina é melhor, mas em grandes profundidades, granularidades fina e grossa são equivalentes.</td>
</tr>
<tr class="odd">
<td>Método de Seleção</td>
<td>O método “all” é melhor, mas o “best” melhora a eficiência sem grandes perdas de qualidade.</td>
</tr>
</tbody>
</table>
<p>No artigo, as estratégias utilizadas são denotadas por siglas que combinam várias letras, cada uma representando um hiperparâmetro específico da metodologia aplicada. Abaixo segue uma explicação simplificada do que cada letra nas iniciais das estratégias representa:</p>
<ul>
<li>L: Refere-se ao uso de discretização local.</li>
<li>G: Refere-se ao uso de discretização global.</li>
<li>B: Indica o uso de intervalos binários.</li>
<li>N: Indica o uso de intervalos nominais.</li>
<li>F: Representa a abordagem de granulidade fina na discretização dos dados.</li>
<li>C: Representa a abordagem de granulidade grossa na discretização dos dados.</li>
<li>A: Refere-se à categoria All no método de seleção.</li>
<li>B: Refere-se à categoria Best no método de seleção.</li>
</ul>
<p>Assim, por exemplo, uma estratégia LBFA aplica discretização local com intervalos binários, granularidade fina e método de seleção “all”.</p>
<p>Por fim, os autores apresentaram uma tabela dos resultados com as melhores escolhas para as 4 dimensões de estratégias em forma de ranking. Essa tabela se divide em duas partes, a primeira coluna que é baseada apenas na avaliação do melhor subgrupo gerado e a segunda leva em conta os 10 melhores subgrupos.</p>
<figure align="center" class="figure">
<img src="imgs/artigo5/tabelaranking.png" style="max-width: 100%;" class="figure-img">
<figcaption>
Rank final das estratégias utilizadas
</figcaption>
</figure>
<p>De modo geral, os melhores resultados foram obtidos pelas estratégias LBFA e LBFB. Entretanto, esse ranking geral não tem garantia de estatística, visto que ele foi criado a partir de uma combinação de vários testes.</p>
<p>Vale ressaltar que uma estratégia em particular (LXFB) também apresentou resultados bons mas se distingue das demais por usar intervalos cartesianos como técnica de discretização, ao invés dos binários ou nominais. Devido às suas limitações de aplicabilidade, ela foi testada separadamente e teve performance melhor que todas as demais, sendo a melhor estratégia quando o objetivo principal é obter subgrupos de alta qualidade para classificação. No entanto, ela não é aplicável para regressão.</p>
</section>
<section id="aplicações-e-desafios" class="level2">
<h2 class="anchored" data-anchor-id="aplicações-e-desafios">Aplicações e desafios</h2>
<p>A descoberta de subgrupos com atributos numéricos tem diversas aplicações, como por exemplo nas áreas da saúde, educação e setor financeiro. No entanto, também apresenta desafios específicos em cada uma dessas áreas.</p>
<p>Na saúde, os modelos podem ser utilizados para predição de riscos, identificando subgrupos de pessoas mais suscetíveis a doenças de alto risco. Além disso, são úteis na análise de resposta a tratamentos, permitindo encontrar subgrupos que reagem de forma diferenciada a determinadas terapias, e no controle de doenças crônicas, identificando subgrupos que necessitam de cuidados específicos. Outra aplicação interessante é o mapeamento de áreas de risco em uma cidade, identificando regiões negligenciadas pelo sistema de saúde, que necessitem de maior atenção e investimento.</p>
<p>Na educação, os modelos de descoberta de subgrupos podem ser aplicados para melhorar a performance acadêmica, identificando subgrupos de alunos com características similares para personalizar a abordagem pedagógica. Outra aplicação potencial é a predição de desistência, onde é possível identificar subgrupos de alunos com maiores índices de evasão, e assim, oferecer medidas de apoio adequadas. Adicionalmente, é possível identificar áreas de risco educacional, destacando regiões com baixo investimento em educação para criação de novas políticas públicas que visem melhorar a qualidade do ensino nessas áreas.</p>
<p>No setor financeiro, os modelos podem ser utilizados para otimização de portfólio, identificando subgrupos de ações que melhor se encaixam no perfil de determinados investidores. Além disso, também podem ser empregados na detecção de fraude, identificando subgrupos de transações que apresentam características anômalas. Na análise de crédito, é possível identificar subgrupos de pessoas com maior propensão a cometer fraudes bancárias, a fim de adotar medidas preventivas.</p>
<p>Apesar dos benefícios das diversas aplicações, a descoberta de subgrupos com atributos numéricos apresenta desafios comuns nas três áreas discutidas. A privacidade dos dados é uma preocupação constante, sendo necessário garantir o controle sobre onde os dados, como serão utilizados e quem pode acessá-los. A discriminação e a equidade de tratamento também são questões importantes, uma vez que a identificação de subgrupos pode gerar preferência de tratamento para determinados grupos, prejudicando outros.</p>
</section>
<section id="execução-dos-algoritmos-usados-no-artigo" class="level2">
<h2 class="anchored" data-anchor-id="execução-dos-algoritmos-usados-no-artigo">Execução dos algoritmos usados no artigo</h2>
<p>Dois repositórios podem ser destacados para a execução do código proposto para análise de algoritmos de descoberta de subgrupos. O primeiro repositório é o da Universidade de Leiden, que disponibiliza o sistema Cortana. Esse sistema possui tanto o código-fonte quanto o binário compilado para execução. A <a href="https://datamining.liacs.nl/cortana.html">página oficial do Cortana</a> fornece informações gerais sobre a ferramenta e o <a href="https://datamining.liacs.nl/cortanajar.html">binário</a> pode ser baixado diretamente da página disponibilizada. Além disso, o <a href="https://datamining.liacs.nl/cortanasources.html">código-fonte</a> está disponível para desenvolvedores que desejam explorar ou modificar o sistema.</p>
<p>O Cortana se destaca pela sua documentação extensa, encontrada no diretório /javadoc do código-fonte. No entanto, apresenta uma limitação significativa: a falta de um histórico de atualizações e uma descrição detalhada das funções. Isso pode dificultar a compreensão completa do sistema e a rastreabilidade de mudanças ao longo do tempo, o que é crucial para desenvolvedores e pesquisadores que precisam entender a evolução do software.</p>
<p>O segundo repositório discutido foi o <a href="https://github.com/SubDisc/SubDisc">SubDisc</a>, disponível no GitHub e atualizado regularmente, com a última atualização registrada em 12 de outubro de 2023. O SubDisc é escrito em Java e se foca principalmente na usabilidade e interface do usuário. Uma das grandes vantagens desse repositório é a inclusão de um guia detalhado em PDF, que fornece instruções claras sobre como utilizar a ferramenta, tornando-a acessível mesmo para aqueles que não são especialistas na área.</p>
<p>A qualidade dos repositórios varia, mas ambos têm suas particularidades e utilidades. O Cortana, apesar de sua documentação extensa, carece de detalhes históricos e descrições de funções, o que pode ser um desafio. Por outro lado, o SubDisc se sobressai com sua documentação voltada para o usuário final e um guia de uso detalhado, embora não haja menção à profundidade da documentação técnica. A escolha entre essas ferramentas dependerá das necessidades específicas dos usuários, seja para um entendimento profundo do funcionamento interno ou para uma interface de usuário amigável.</p>
<p>Um teste foi realizado utilizando a ferramenta Cortana. O dataset utilizado, tanto para regressão, quanto para classificação, foi o <a href="https://archive.ics.uci.edu/dataset/2/adult">Adult</a>, do repositório de Machine Learning da UCI. Na tarefa de classificação, o foco foi buscar subgrupos que apresentam um comportamento diferente da população em relação à variável binária “renda anual ≥ 50k”. Na tarefa de regressão, o foco está na idade dos indivíduos, verificando se há subgrupos com uma distribuição de idade atípica em relação à população geral.</p>
<p>Para instalar o Cortana, baixe o arquivo <a href="https://datamining.liacs.nl/cortanajar.html">cortana1782.jar</a> e execute-o com o comando java abaixo na linha de comando.</p>
<pre><code>java -jar cortana1782.jar</code></pre>
<p>Após iniciar o programa, selecione o arquivo de dados nos formatos arff ou csv, ajuste os parâmetros conforme o tipo de objetivo (por exemplo, Single Numeric ou Single Nominal) e as medidas de qualidade desejadas (como Lift ou Z-Score). Verifique se os dados foram identificados corretamente e ajuste os tipos de atributos, desabilitando colunas indesejadas. Configure o método de descoberta, definindo parâmetros como profundidade de refinamento e cobertura mínima e máxima, e utilize a estratégia de beam search com um tamanho de beam de 100. Clique no botão “Subgroup Discovery” para iniciar o processo.</p>
<figure align="center" class="figure">
<img src="imgs/artigo5/iniciocortana.png" style="max-width: 100%;" class="figure-img">
<figcaption>
Inicialização do programa e carga de dados
</figcaption>
</figure>
<p>No primeiro exemplo, para um problema de classificação onde se deseja identificar pessoas com renda anual ≥ 50k, foi configurado o método como Beam Search, com largura do beam de 100, profundidade de refinamento de 2, métrica de qualidade Lift (≥ 1.0) e cobertura entre 10% e 90%. Após selecionar o arquivo adult.csv e ajustar os parâmetros e atributos, a execução do algoritmo resultou em subgrupos como “education-num &gt; 12.0 AND capital-gain &gt; 5000”, com uma AUC de 0.85 na curva ROC.</p>
<figure align="center" class="figure">
<img src="imgs/artigo5/resultadosclassificacao.png" style="max-width: 100%;" class="figure-img">
<figcaption>
Subgrupos resultantes classificação
</figcaption>
</figure>
<p>No segundo exemplo do problema de regressão, para identificar distribuições não usuais de idade, a configuração também incluiu Beam Search, com largura do beam de 100, profundidade de refinamento de 2 e cobertura entre 10% e 90%. Todavia, a métrica de qualidade foi Z-Score (≥ 2.0). A execução encontrou subgrupos como “relationship = husband AND hours-per-week &gt; 40”, permitindo a comparação da distribuição de idade com a população geral.</p>
<figure align="center" class="figure">
<img src="imgs/artigo5/resultadosregressao.png" style="max-width: 100%;" class="figure-img">
<figcaption>
Subgrupos resultantes regressão
</figcaption>
</figure>
</section>
<section id="conclusão" class="level2">
<h2 class="anchored" data-anchor-id="conclusão">Conclusão</h2>
<p>O trabalho cumpre um papel importate na realização de experimentos capazes de confirmar algumas intuições não validadas até então e aprimorar o conhecimento em relações a estratégias numéricas. Nesse sentido, é um estudo bastante útil tanto em uma perspectiva aplicada, podendo servir como apoio na decisão de aspectos em aplicações reais, quanto no contexto de pesquisas e desenvolvimento de algoritmos.</p>
</section>
<section id="referências" class="level2">
<h2 class="anchored" data-anchor-id="referências">Referências</h2>
<p>Boley M, Goldsmith BR, Ghiringhelli LM, Vreeken J (2017) Identifying consistent statements about numerical data with dispersion-corrected subgroup discovery. Data Min Knowl Discov 31(5):1391–1418. https://doi.org/10.1007/s10618-017-0520-3.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/DCC831-Aprendizado-Descritivo\.github\.io\/2024\.1\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>